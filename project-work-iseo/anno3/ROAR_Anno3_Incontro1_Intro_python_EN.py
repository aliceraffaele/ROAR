# -*- coding: utf-8 -*-
"""intro_python_EN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SMHWys6A2N1ZFcEHnOPneOvfv94uP1rW

# **INTRODUCTION TO PYTHON BASIC NOTIONS**

**DYNAMIC TYPING OF VARIABLES**

In Python, it is sufficient to assign data to a variable without specifying its type, because this will be recognized automatically.
"""

x1 = 2
x2 = 'Hello'
x3 = 3.4

"""x1 is an **integer**, x2 is a **string**, x3 is a **float** (decimal number)
print(x2 + x1) would give an error:
"""

print(x2 + x1)

"""The correct way to do this is as follows:"""

print(x2 + ' ' + str(x1))

"""## **CYCLES**

**THE FOR CYCLE**

Syntax:

for i in S:
> operations

For each element i of a certain set S, it performs some operations...

*Example with the range function*

Suppose you want to print all numbers up to 10.
"""

N = 10
for i in range(N+1):
  print(str(i))

"""The range function can receive one or two **parameters**:

* if it receives only one parameter, as in range(N+1), then the returned set will be the entire range [0, N+1) = [0, N]
* if it receives two parameters, as in range(a, b), then the returned set will be the entire range [a, b) = [a, b-1]

*Example with a = 2 and b = 5*
"""

a = 2
b = 5
for i in range(a, b):
  print(str(i))

"""**THE WHILE CYCLE**

Syntax:

while condition:
> operations

Until a certain condition occurs, some operations are performed repeatedly...

*Example similar to the one seen with the for loop*

Suppose you want to print all numbers up to 10.
"""

i = 0
while i < 11:
    print(str(i))
    i += 1 # i = i + 1

"""What if the instructions were reversed?"""

i = 0
while i < 11:
    i += 1 # i = i + 1
    print(str(i))

"""The number 11 would also be printed because the condition check

```
while i < 11:
```


would happen **after** the command

```
print(str(i))
```

**NB**: pay attention to the order of the instructions!

**CONCATENATION OF STRINGS AND OTHER OBJECTS**
"""

s1 = 'Hello'
s2 = 'world'
# Mode 1
print(s1 + ' ' + s2)

# Mode 2
print('{} {}'.format(s1, s2))

"""This other way is more convenient when there are objects other than strings that need to be printed.

*Example*:
"""

pi = 3.14
# Mode 1
print(s1 + ' ' + str(pi))
# Mode 2
print('{} {}'.format(s1, pi))

"""**LISTS**"""

# Mode 1 to define a list: indicating all its elements
list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Mode 2 to define a list: from empty, adding elements
list2 = []
N = 13
for x in range(1,N+1):
  list2.append(x) # or: list2 += [x]
print(list2)

# Mode 2 (more compact) to define a list: by exploiting a for loop
list2 = [x for x in range(1,N+1)]
print(list2)

"""**OPERATIONS WITH LISTS**"""

# Length
print('list1 contains ' + str(len(list1)) + ' elements')

# Concatenation of two lists
list3 = list1 + list2
print(list3)

# Union of two lists by removing the repeating elements -> Set
set1 = set(list1 + list2)
print(set1)

# Repetition
list4 = ['Hello!']*4
print(list4)

# Membership (or not) of an element in a list
print(3 in list3)
print(100 in list3)
print(100 not in list3)

# Iterating over the elements of a list
for x in list2:
   print('The square of {} is {}'.format(x, pow(x,2)))

# Indexing
L = [10, 3, 5, 6, 22, 18, 90]
print('The third element of list L is ' + str(L[2])) # Indexing starts from 0 and not from 1
print('The last element of list L is ' + str(L[len(L)-1])) # The last element has index len(L)-1, not just len(L)!

print('Length of list L = {}'.format(len(L)))
print(L (len(L)))

# Indexing with negative numbers, counting from the right
print('The last element of list L is ' + str(L[-1]))

# Pieces of list
print(L[2:5]) # Print elements in positions 2, 3 and 4 (excluding 5)

# Updating an element of a list
L[2] = 33
print(L)

"""**TUPLE (read-only lists)**

They differ from lists because the elements of a tuple are enclosed in two parentheses and cannot be updated
"""

tuple1 = (1, 2, 3)
print(tuple1)

tuple1[2] = 33

"""**MATRICES**"""

# a is a 2-D matrix
a = [['Roy',80,75,85,90,95],
      ['John',75,80,75,85,100],
      ['Dave',80,80,80,90,95]]
print(a)

# b is a nested list, but not an array: why?
b= [['Roy',80,75,85,90,95],
     ['John',75,80,75],
     ['Dave',80,80,80,90,95]]
print(b)

# One of several ways to define an array
num_rows = 5
num_columns = 4
m_row = [x for x in range(1, num_columns+1)]
m1 = []
for i in range(num_rows):
     m1 += [[x+i for x in m_row]]
print("m1 = " + str(m1))

# Another way
m = [[0 for y in range(num_columns)] for x in range(num_rows)]
print(m)

# Adding [1,2,3,4,5] to m using the += operator
m += [[1,2,3,4,5]]
print(m)
print('\n')

# Print m using a for loop for better visualization
for i in range(len(m)):
     print(m[i])

# Removing the last line added to m with the del operator
del m[len(m)-1]
print(m)

"""**FUNCTIONS**

They are procedures that are defined before being called and which can receive parameters to use. Generally, a function can also return one or more results (but this is not mandatory).
"""

def fun1(p1, p2):
    return p1 + 2*p2

p1 = 5
p2 = 3
p3 = fun1(p1, p2)
print('p3 = ' + str(p3))

"""**NB**: the passing of parameters is done *by reference* and not by value."""

def fun2(a, b):
   a = 2*a
   b = int(b/2)
   return a + b

a = 3
b = 5
print('Result of fun2 = {}'.format(fun2(a,b)))
print('After fun2, a = {} and b = {}'.format(a,b))

"""But be careful when passing objects like lists!"""

def fun3(c, d, l):
   l += [c*d, int(c/d), round(c/d, 2)]
   return l

l = [2, 4, 6]
print('List l before fun2 = ' + str(l))
c = 10
d = 3
fun3(c, d, l)
print('List l after fun2 = ' + str(l))

